name: Deploy to Bare Metal AWS

on:
  push:
    branches: [dev]

env:
  AWS_REGION: eu-central-1
  EC2_INSTANCE_ID: i-0d20ef67ddf31ea1c
  DEPLOY_DIR: /home/ubuntu/baremetal

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy to Bare Metal via SSM
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy via SSM
        id: ssm_deploy
        run: |
          # Command to run on the EC2 instance
          DEPLOY_SCRIPT="
          set -e
          echo '--- Starting Bare Metal Deployment ---'
          cd ${{ env.DEPLOY_DIR }}

          echo 'Pulling latest code...'
          git fetch origin dev
          git reset --hard origin/dev

          echo 'Updating dependencies...'
          source venv/bin/activate
          pip install -r requirements-linux.txt

          echo 'Restarting application service...'
          sudo systemctl restart pyelli

          echo 'Checking service status...'
          sudo systemctl is-active pyelli

          echo '--- Deployment Complete ---'
          "

          # Encode script to avoid escaping issues
          ENCODED_SCRIPT=$(echo "$DEPLOY_SCRIPT" | base64 -w 0)

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploying PyElli bare metal from commit ${{ github.sha }}" \
            --parameters "commands=[
              'echo $ENCODED_SCRIPT | base64 -d | bash'
            ]" \
            --query 'Command.CommandId' \
            --output text)

          if [ -z "$COMMAND_ID" ]; then
            echo "Failed to send SSM command."
            exit 1
          fi

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for command completion..."

          timeout_seconds=300
          interval_seconds=10
          elapsed_seconds=0

          while [ $elapsed_seconds -lt $timeout_seconds ]; do
            STATUS_INFO=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ env.EC2_INSTANCE_ID }}" \
              --query "{Status:Status,StatusDetails:StatusDetails}" \
              --output json)

            STATUS=$(echo "$STATUS_INFO" | jq -r .Status)
            STATUS_DETAILS=$(echo "$STATUS_INFO" | jq -r .StatusDetails)
            echo "Status: $STATUS ($STATUS_DETAILS)"

            if [[ "$STATUS" == "Success" ]]; then
              echo "✅ Deployment successful!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ env.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              exit 0
            elif [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              echo "❌ Deployment failed: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ env.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi

            sleep $interval_seconds
            elapsed_seconds=$((elapsed_seconds + interval_seconds))
          done

          echo "⌛ Command timed out after $timeout_seconds seconds"
          exit 1
