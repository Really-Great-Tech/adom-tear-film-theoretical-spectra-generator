name: Deploy to AWS

on:
  push:
    branches: [dev]

env:
  AWS_REGION: eu-central-1
  ECR_REPOSITORY: pyelli-app
  EC2_INSTANCE_ID: i-0d20ef67ddf31ea1c

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Build and Deploy via SSM
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy to EC2 via SSM
        id: ssm_deploy
        run: |
          ECR_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest"

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploying PyElli app from commit ${{ github.sha }}" \
            --parameters "commands=[
              'set -e',
              'echo \"--- Starting PyElli deployment ---\"',
              'cd /opt/pyelli-app',
              'aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}',
              'echo \"ECR login successful.\"',
              'export ECR_IMAGE=${ECR_IMAGE}',
              'echo \"Pulling image: ${ECR_IMAGE}\"',
              'docker compose pull streamlit',
              'echo \"Image pull complete.\"',
              'echo \"Restarting services...\"',
              'docker compose up -d --remove-orphans',
              'echo \"Services restarted.\"',
              'docker image prune -af',
              'echo \"--- Deployment complete ---\"'
            ]" \
            --query 'Command.CommandId' \
            --output text)

          if [ -z "$COMMAND_ID" ]; then
            echo "Failed to send SSM command."
            exit 1
          fi

          echo "SSM Command ID: $COMMAND_ID"
          echo "Waiting for command completion..."

          timeout_seconds=300
          interval_seconds=10
          elapsed_seconds=0

          while [ $elapsed_seconds -lt $timeout_seconds ]; do
            STATUS_INFO=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ env.EC2_INSTANCE_ID }}" \
              --query "{Status:Status,StatusDetails:StatusDetails}" \
              --output json)

            STATUS=$(echo "$STATUS_INFO" | jq -r .Status)
            STATUS_DETAILS=$(echo "$STATUS_INFO" | jq -r .StatusDetails)
            echo "Status: $STATUS ($STATUS_DETAILS)"

            if [[ "$STATUS" == "Success" ]]; then
              echo "✅ Deployment successful!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ env.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              exit 0
            elif [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              echo "❌ Deployment failed: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ env.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi

            sleep $interval_seconds
            elapsed_seconds=$((elapsed_seconds + interval_seconds))
          done

          echo "⌛ Command timed out after $timeout_seconds seconds"
          exit 1
